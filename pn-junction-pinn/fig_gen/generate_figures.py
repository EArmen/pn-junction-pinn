# -*- coding: utf-8 -*-
"""Untitled146.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SvCVasckE7bwrsXZ3JZW7l6jXuQZd3vs
"""

pip install numpy matplotlib

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import os

# Создаем директорию для сохранения фигур
os.makedirs('article_figures', exist_ok=True)

# Фигура 1: Распределения электрического поля и потенциала
def create_fig1():
    x = np.linspace(-0.5, 0.5, 100)
    E = np.where(x < 0, -x - 0.25, 0.25 - x)
    V = 0.5 * x**2 - 0.125

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    ax1.plot(x, E, 'b-', linewidth=2)
    ax1.set_title('(a) Electric Field Distribution')
    ax1.set_xlabel('Position (μm)')
    ax1.set_ylabel('Electric Field (V/μm)')
    ax1.grid(True)

    ax2.plot(x, V, 'r-', linewidth=2)
    ax2.set_title('(b) Electrostatic Potential')
    ax2.set_xlabel('Position (μm)')
    ax2.set_ylabel('Potential (V)')
    ax2.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig1_ElectricField_Potential.pdf')
    plt.close()

# Фигура 2: Ошибка аналитической модели
def create_fig2():
    doping = np.array([1e16, 1e17, 1e18, 1e19, 1e20])
    error = np.array([0.012, 0.082, 0.47, 1.83, 3.25])

    plt.figure(figsize=(8, 6))
    plt.semilogx(doping, error, 'ro-', linewidth=2, markersize=8)
    plt.title('Analytical Model Error Growth with Doping Concentration')
    plt.xlabel('Doping Concentration (cm⁻³)')
    plt.ylabel('Maximum Error (V)')
    plt.grid(True, which='both', linestyle='--')
    plt.savefig('article_figures/Fig2_ErrorGrowth.pdf')
    plt.close()

# Фигура 3: Экспериментальные установки
def create_fig3():
    fig = plt.figure(figsize=(12, 4))
    gs = GridSpec(1, 3, figure=fig)

    ax1 = fig.add_subplot(gs[0, 0])
    ax1.set_title('(a) SRP Measurement Setup')
    ax1.text(0.5, 0.5, 'SRP Probe\nScanning System', ha='center', va='center')
    ax1.axis('off')

    ax2 = fig.add_subplot(gs[0, 1])
    ax2.set_title('(b) C-V Characterization')
    ax2.text(0.5, 0.5, 'Capacitance-Voltage\nMeasurement Setup', ha='center', va='center')
    ax2.axis('off')

    ax3 = fig.add_subplot(gs[0, 2])
    ax3.set_title('(c) TEM Cross-section')
    ax3.text(0.5, 0.5, 'Transmission Electron\nMicroscopy Image', ha='center', va='center')
    ax3.axis('off')

    plt.tight_layout()
    plt.savefig('article_figures/Fig3_Experimental_Setups.pdf')
    plt.close()

# Фигура 4: Производительность
def create_fig4():
    mesh = np.array([1e3, 1e4, 1e5, 1e6])
    time = np.array([0.1, 1, 10, 100])
    error = np.array([10, 5, 2, 0.5])

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

    ax1.loglog(mesh, time, 'bo-')
    ax1.set_title('(a) Runtime vs Mesh Complexity')
    ax1.set_xlabel('Number of Mesh Points')
    ax1.set_ylabel('Runtime (s)')
    ax1.grid(True)

    ax2.semilogy(time, error, 'rs-')
    ax2.set_title('(b) Accuracy-Runtime Trade-off')
    ax2.set_xlabel('Runtime (s)')
    ax2.set_ylabel('RMS Error (%)')
    ax2.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig4_Performance.pdf')
    plt.close()

# Фигура 5: Рабочий процесс
def create_fig5():
    plt.figure(figsize=(10, 6))
    plt.title('Hybrid Simulation-Experimental Workflow')

    # Простая блок-схема
    plt.text(0.1, 0.8, 'Device Fabrication', bbox=dict(facecolor='lightblue', alpha=0.5))
    plt.arrow(0.2, 0.75, 0.1, -0.1, head_width=0.02)

    plt.text(0.3, 0.6, 'Characterization\n(SRP, C-V, TEM)', bbox=dict(facecolor='lightgreen', alpha=0.5))
    plt.arrow(0.4, 0.55, 0.1, 0.0, head_width=0.02)

    plt.text(0.5, 0.6, 'TCAD Simulation', bbox=dict(facecolor='salmon', alpha=0.5))
    plt.arrow(0.6, 0.55, 0.1, 0.0, head_width=0.02)

    plt.text(0.7, 0.6, 'PINN Training', bbox=dict(facecolor='violet', alpha=0.5))
    plt.arrow(0.8, 0.55, 0.1, -0.1, head_width=0.02)

    plt.text(0.9, 0.4, 'Device Optimization', bbox=dict(facecolor='gold', alpha=0.5))

    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.axis('off')
    plt.savefig('article_figures/Fig5_Workflow.pdf')
    plt.close()

# Фигура 6: Сравнение моделей
def create_fig6():
    x = np.linspace(-1, 1, 100)

    # Low doping
    V_analytical_low = 0.5 * x**2
    V_numerical_low = 0.52 * x**2 - 0.01

    # High doping
    V_analytical_high = 0.9 * x**2
    V_numerical_high = 0.85 * np.abs(x)**1.5

    fig, axs = plt.subplots(2, 2, figsize=(12, 10))

    # Low doping - Electric Field
    axs[0, 0].plot(x, -np.gradient(V_analytical_low, x), 'b-', label='Analytical')
    axs[0, 0].plot(x, -np.gradient(V_numerical_low, x), 'r--', label='Numerical')
    axs[0, 0].set_title('(a) Low Doping: Electric Field')
    axs[0, 0].set_ylabel('E (V/μm)')
    axs[0, 0].legend()
    axs[0, 0].grid(True)

    # Low doping - Potential
    axs[0, 1].plot(x, V_analytical_low, 'b-', label='Analytical')
    axs[0, 1].plot(x, V_numerical_low, 'r--', label='Numerical')
    axs[0, 1].set_title('(b) Low Doping: Potential')
    axs[0, 1].set_ylabel('ψ (V)')
    axs[0, 1].legend()
    axs[0, 1].grid(True)

    # High doping - Electric Field
    axs[1, 0].plot(x, -np.gradient(V_analytical_high, x), 'b-', label='Analytical')
    axs[1, 0].plot(x, -np.gradient(V_numerical_high, x), 'r--', label='Numerical')
    axs[1, 0].set_title('(c) High Doping: Electric Field')
    axs[1, 0].set_xlabel('Position (μm)')
    axs[1, 0].set_ylabel('E (V/μm)')
    axs[1, 0].legend()
    axs[1, 0].grid(True)

    # High doping - Potential
    axs[1, 1].plot(x, V_analytical_high, 'b-', label='Analytical')
    axs[1, 1].plot(x, V_numerical_high, 'r--', label='Numerical')
    axs[1, 1].set_title('(d) High Doping: Potential')
    axs[1, 1].set_xlabel('Position (μm)')
    axs[1, 1].set_ylabel('ψ (V)')
    axs[1, 1].legend()
    axs[1, 1].grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig6_Model_Comparison.pdf')
    plt.close()

# Фигура 7: Архитектура PINN
def create_fig7():
    plt.figure(figsize=(10, 8))
    plt.title('Proposed PINN Architecture with Fourier Features and Residual Blocks')

    # Упрощенное представление архитектуры
    plt.text(0.1, 0.9, 'Input\nPosition', bbox=dict(facecolor='lightblue'))
    plt.text(0.3, 0.9, 'Fourier\nFeatures', bbox=dict(facecolor='lightgreen'))
    plt.text(0.5, 0.7, 'Residual\nBlock 1', bbox=dict(facecolor='salmon'))
    plt.text(0.5, 0.5, 'Residual\nBlock 2', bbox=dict(facecolor='salmon'))
    plt.text(0.5, 0.3, 'Residual\nBlock 3', bbox=dict(facecolor='salmon'))
    plt.text(0.7, 0.7, 'Potential\nOutput', bbox=dict(facecolor='violet'))
    plt.text(0.7, 0.5, 'Field\nOutput', bbox=dict(facecolor='violet'))
    plt.text(0.7, 0.3, 'C-V\nOutput', bbox=dict(facecolor='violet'))

    # Соединения
    plt.arrow(0.2, 0.9, 0.08, 0, head_width=0.02)
    plt.arrow(0.4, 0.9, 0.08, -0.2, head_width=0.02)
    plt.arrow(0.4, 0.9, 0.08, -0.4, head_width=0.02)
    plt.arrow(0.4, 0.9, 0.08, -0.6, head_width=0.02)
    plt.arrow(0.6, 0.7, 0.08, 0, head_width=0.02)
    plt.arrow(0.6, 0.5, 0.08, 0, head_width=0.02)
    plt.arrow(0.6, 0.3, 0.08, 0, head_width=0.02)

    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.axis('off')
    plt.savefig('article_figures/Fig7_PINN_Architecture.pdf')
    plt.close()

# Фигура 8: Обучение PINN
def create_fig8():
    epochs = np.arange(1, 1001)
    loss_physics = 10 * np.exp(-epochs/200)
    loss_data = 5 * np.exp(-epochs/150) + 0.1
    alpha = 0.5 + 0.5 * np.tanh((300 - epochs)/100)
    beta = 1 - alpha
    accuracy = 100 - 100 * np.exp(-epochs/100)

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

    ax1.semilogy(epochs, loss_physics, 'r-', label='Physics Loss')
    ax1.semilogy(epochs, loss_data, 'b-', label='Data Loss')
    ax1.set_title('(a) Loss Component Evolution')
    ax1.set_xlabel('Epochs')
    ax1.set_ylabel('Loss Value')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(epochs, alpha, 'g-', label='α(t) - Physics weight')
    ax2.plot(epochs, beta, 'm-', label='β(t) - Data weight')
    ax2.set_title('(b) Adaptive Weights')
    ax2.set_xlabel('Epochs')
    ax2.set_ylabel('Weight Value')
    ax2.legend()
    ax2.grid(True)

    ax3.plot(epochs, accuracy, 'k-')
    ax3.set_title('(c) Validation Accuracy')
    ax3.set_xlabel('Epochs')
    ax3.set_ylabel('Accuracy (%)')
    ax3.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig8_Training_Progress.pdf')
    plt.close()

# Фигура 9: Скорость вывода
def create_fig9():
    models = ['Dense DNN', 'ResNet-18', 'Transformer', 'Our PINN']
    latency = [5.2, 3.8, 8.5, 1.2]
    throughput = [120, 180, 85, 350]

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

    ax1.bar(models, latency, color=['blue', 'orange', 'green', 'red'])
    ax1.set_title('(a) Per-sample Latency')
    ax1.set_ylabel('Latency (ms)')
    ax1.grid(axis='y')

    ax2.bar(models, throughput, color=['blue', 'orange', 'green', 'red'])
    ax2.set_title('(b) Throughput')
    ax2.set_ylabel('Samples/s')
    ax2.grid(axis='y')

    plt.tight_layout()
    plt.savefig('article_figures/Fig9_Inference_Speed.pdf')
    plt.close()

# Фигура 10: Рабочий процесс моделирования
def create_fig10():
    plt.figure(figsize=(10, 6))
    plt.title('Integrated Modeling Workflow: Analytical → Numerical → PINN')

    plt.text(0.1, 0.7, 'Analytical Model\nFast approximation',
             bbox=dict(facecolor='lightblue', alpha=0.7), ha='center')
    plt.arrow(0.3, 0.7, 0.1, 0, head_width=0.03)

    plt.text(0.5, 0.7, 'Numerical Solver\nHigh accuracy',
             bbox=dict(facecolor='lightgreen', alpha=0.7), ha='center')
    plt.arrow(0.7, 0.7, 0.1, 0, head_width=0.03)

    plt.text(0.9, 0.7, 'PINN Acceleration\nReal-time optimization',
             bbox=dict(facecolor='salmon', alpha=0.7), ha='center')

    plt.text(0.5, 0.3, 'Experimental Validation\nSRP, C-V, TEM',
             bbox=dict(facecolor='gold', alpha=0.7), ha='center')

    plt.plot([0.9, 0.7], [0.6, 0.4], 'k--')
    plt.plot([0.7, 0.5], [0.6, 0.4], 'k--')

    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.axis('off')
    plt.savefig('article_figures/Fig10_Modeling_Workflow.pdf')
    plt.close()

# Фигура 11: Сходимость численного решения
def create_fig11():
    dx = np.array([2e-6, 1e-6, 5e-7, 2.5e-7, 1.25e-7])
    error = np.array([0.0112, 0.0061, 0.0038, 0.0022, 0.0015])

    plt.figure(figsize=(8, 6))
    plt.loglog(dx, error, 'bo-', label='Numerical error')
    plt.loglog(dx, 1e4*dx**2, 'r--', label='Quadratic reference')
    plt.title('Quadratic Convergence of Numerical Solution (ε∼(Δx)²)')
    plt.xlabel('Step Size Δx (cm)')
    plt.ylabel('RMS Error (V)')
    plt.legend()
    plt.grid(True, which='both')
    plt.savefig('article_figures/Fig11_Convergence.pdf')
    plt.close()

# Фигура 12: Масштабирование эффективности
def create_fig12():
    grid_points = np.array([1e3, 1e4, 1e5, 1e6, 1e7])
    runtime = np.array([0.1, 1, 10, 100, 1000])
    power = np.array([1, 10, 100, 1000, 10000])

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

    ax1.loglog(grid_points, runtime, 'bo-')
    ax1.set_title('(a) Runtime vs Grid Points')
    ax1.set_xlabel('Grid Points')
    ax1.set_ylabel('Runtime (s)')
    ax1.grid(True)

    ax2.loglog(runtime, power, 'rs-')
    ax2.set_title('(b) Power Efficiency Scaling')
    ax2.set_xlabel('Runtime (s)')
    ax2.set_ylabel('Power Consumption (W)')
    ax2.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig12_Scaling.pdf')
    plt.close()

# Фигура 13: Влияние вариаций легирования
def create_fig13():
    V = np.linspace(-5, 5, 100)
    C_nominal = 1 / np.sqrt(1.2 - 0.2*V**2)
    C_min = 1 / np.sqrt(1.32 - 0.22*V**2)
    C_max = 1 / np.sqrt(1.08 - 0.18*V**2)

    E_nominal = np.abs(V)**0.7
    E_min = 0.9*np.abs(V)**0.7
    E_max = 1.1*np.abs(V)**0.7

    V_br_nominal = 10 - 2*V
    V_br_min = 9 - 1.8*V
    V_br_max = 11 - 2.2*V

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

    ax1.plot(V, C_nominal, 'b-', label='Nominal')
    ax1.plot(V, C_min, 'r--', label='-10% doping')
    ax1.plot(V, C_max, 'g--', label='+10% doping')
    ax1.set_title('(a) C-V Curves')
    ax1.set_xlabel('Voltage (V)')
    ax1.set_ylabel('Capacitance (a.u.)')
    ax1.legend()
    ax1.grid(True)

    ax2.plot(V, E_nominal, 'b-', label='Nominal')
    ax2.plot(V, E_min, 'r--', label='-10% doping')
    ax2.plot(V, E_max, 'g--', label='+10% doping')
    ax2.set_title('(b) Electric Field')
    ax2.set_xlabel('Position (μm)')
    ax2.set_ylabel('Field Strength (V/μm)')
    ax2.legend()
    ax2.grid(True)

    ax3.plot(V, V_br_nominal, 'b-', label='Nominal')
    ax3.plot(V, V_br_min, 'r--', label='-10% doping')
    ax3.plot(V, V_br_max, 'g--', label='+10% doping')
    ax3.set_title('(c) Breakdown Voltage')
    ax3.set_xlabel('Doping Concentration (cm⁻³)')
    ax3.set_ylabel('Breakdown Voltage (V)')
    ax3.legend()
    ax3.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig13_Doping_Variation.pdf')
    plt.close()

# Фигура 14: Анализ FinFET
def create_fig14():
    z = np.linspace(0, 50, 100)
    doping = 1e20 * np.exp(-(z-25)**2/50)
    potential = 0.8 * (1 - np.tanh((z-25)/10))
    Vg = np.linspace(0, 1, 50)
    Id = 0.1 * Vg**2

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

    ax1.semilogy(z, doping, 'b-')
    ax1.set_title('(a) Doping Profile')
    ax1.set_xlabel('Depth (nm)')
    ax1.set_ylabel('Doping (cm⁻³)')
    ax1.grid(True)

    ax2.plot(z, potential, 'r-')
    ax2.set_title('(b) Potential Distribution')
    ax2.set_xlabel('Position (nm)')
    ax2.set_ylabel('Potential (V)')
    ax2.grid(True)

    ax3.plot(Vg, Id, 'g-')
    ax3.set_title('(c) $I_d$-$V_g$ Characteristics')
    ax3.set_xlabel('Gate Voltage $V_g$ (V)')
    ax3.set_ylabel('Drain Current $I_d$ (A)')
    ax3.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig14_FinFET_Analysis.pdf')
    plt.close()

# Фигура 15: Архитектура плагина
def create_fig15():
    plt.figure(figsize=(10, 6))
    plt.title('Cadence Virtuoso Plugin Architecture')

    # Компоненты
    plt.text(0.1, 0.8, 'Simulation Engine', bbox=dict(facecolor='lightblue', alpha=0.7))
    plt.text(0.4, 0.8, 'Optimization', bbox=dict(facecolor='lightgreen', alpha=0.7))
    plt.text(0.7, 0.8, 'EDA Tools', bbox=dict(facecolor='salmon', alpha=0.7))

    plt.text(0.1, 0.5, 'Process Design Kit', bbox=dict(facecolor='gold', alpha=0.7))
    plt.text(0.4, 0.5, 'Layout', bbox=dict(facecolor='violet', alpha=0.7))
    plt.text(0.7, 0.5, 'Verification', bbox=dict(facecolor='cyan', alpha=0.7))

    # Соединения
    plt.plot([0.2, 0.3], [0.8, 0.8], 'k-')
    plt.plot([0.5, 0.6], [0.8, 0.8], 'k-')
    plt.plot([0.1, 0.1], [0.7, 0.55], 'k--')
    plt.plot([0.4, 0.4], [0.7, 0.55], 'k--')
    plt.plot([0.7, 0.7], [0.7, 0.55], 'k--')

    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.axis('off')
    plt.savefig('article_figures/Fig15_Plugin_Architecture.pdf')
    plt.close()

# Фигура 16: Дорожная карта исследований
def create_fig16():
    plt.figure(figsize=(10, 6))
    plt.title('Multidisciplinary Research Roadmap')

    # Временная шкала
    years = ['2023', '2024', '2025', '2026']
    plt.plot([0.1, 0.9], [0.5, 0.5], 'k-', linewidth=2)

    # Вехи
    plt.text(0.1, 0.6, 'PINN Framework v1.0', bbox=dict(facecolor='lightblue'))
    plt.text(0.3, 0.7, '3D Extension', bbox=dict(facecolor='lightgreen'))
    plt.text(0.5, 0.4, 'Quantum Solvers', bbox=dict(facecolor='salmon'))
    plt.text(0.7, 0.6, 'Industrial Adoption', bbox=dict(facecolor='gold'))

    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.axis('off')
    plt.savefig('article_figures/Fig16_Research_Roadmap.pdf')
    plt.close()

# Фигура 17: Температурная зависимость
def create_fig17():
    V = np.linspace(-5, 5, 100)
    temperatures = [100, 200, 300, 400, 500]

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

    # PINN Model
    for T in temperatures:
        C = 1 / np.sqrt(1.0 - 0.15*V**2 + 0.001*T)
        ax1.plot(V, C, label=f'{T}K')
    ax1.set_title('(a) PINN Model')
    ax1.set_xlabel('Voltage (V)')
    ax1.set_ylabel('Capacitance (a.u.)')
    ax1.legend()
    ax1.grid(True)

    # Sentaurus TCAD
    for T in temperatures:
        C = 1 / np.sqrt(1.1 - 0.16*V**2 + 0.0012*T)
        ax2.plot(V, C, label=f'{T}K')
    ax2.set_title('(b) Sentaurus TCAD')
    ax2.set_xlabel('Voltage (V)')
    ax2.legend()
    ax2.grid(True)

    # Experimental Data
    for T in temperatures:
        C = 1 / np.sqrt(0.95 - 0.14*V**2 + 0.0009*T) + 0.02*np.random.normal(size=len(V))
        ax3.plot(V, C, label=f'{T}K')
    ax3.set_title('(c) Experimental Data')
    ax3.set_xlabel('Voltage (V)')
    ax3.legend()
    ax3.grid(True)

    plt.tight_layout()
    plt.savefig('article_figures/Fig17_Temperature_Dependence.pdf')
    plt.close()

# Генерация всех фигур
create_fig1()
create_fig2()
create_fig3()
create_fig4()
create_fig5()
create_fig6()
create_fig7()
create_fig8()
create_fig9()
create_fig10()
create_fig11()
create_fig12()
create_fig13()
create_fig14()
create_fig15()
create_fig16()
create_fig17()

print("Все фигуры успешно сгенерированы и сохранены в папке 'article_figures'")